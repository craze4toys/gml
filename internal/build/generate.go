/*
 *  GML - Go QML
 *  Copyright (c) 2019 Roland Singer [roland.singer@deserbit.com]
 *  Copyright (c) 2019 Sebastian Borchers [sebastian@deserbit.com]
 */

package build

import (
	"os"
	"path/filepath"
	"strings"
)

const (
	genGoFilename = "gml_gen.go"
)

// TODO: make concurrent with multiple goroutines.
func generate(ctx *Context) (err error) {
	// TODO: skip all gml_gen.go files?
	gt, err := parseDirRecursive(ctx.SourceDir)
	if err != nil {
		return
	}

	for _, gp := range gt.Packages {
		err = generateGoPackageFile(gp)
		if err != nil {
			return
		}

		err = generateCPPPackageFile(gp, ctx.CPPGenDir)
		if err != nil {
			return
		}
	}
	return
}

func generateGoPackageFile(gp *genPackage) (err error) {
	filename := filepath.Join(gp.Dir, genGoFilename)

	// Create the file.
	f, err := os.Create(filename)
	if err != nil {
		return
	}
	defer func() {
		derr := f.Close()
		if derr != nil && err == nil {
			err = derr
		}
	}()

	// Write the header.
	f.WriteString("// This file is auto-generated by gml.\n")
	f.WriteString("package " + gp.Name + "\n\n")

	for _, st := range gp.Structs {
		// Add all signals.
		for _, s := range st.Signals {
			f.WriteString("func (_s *" + st.Name + ") " + s.Name + "(")

			// Add the parameters.
			for i, p := range s.Params {
				if i != 0 {
					f.WriteString(", ")
				}
				f.WriteString(p.Name + " " + p.Type)
			}

			f.WriteString(") {\n")
			// TODO:
			f.WriteString("}\n\n")
		}
	}

	return
}

func generateCPPPackageFile(gp *genPackage, genDir string) (err error) {
	filename := filepath.Join(genDir, gp.Name+".h")

	// Create the file.
	f, err := os.Create(filename)
	if err != nil {
		return
	}
	defer func() {
		derr := f.Close()
		if derr != nil && err == nil {
			err = derr
		}
	}()

	// Write the header.
	f.WriteString("// This file is auto-generated by gml.\n")
	f.WriteString("#ifndef GML_GEN_CPP_" + strings.ToUpper(gp.Name) + "_H\n")
	f.WriteString("#define GML_GEN_CPP_" + strings.ToUpper(gp.Name) + "_H\n\n")
	f.WriteString("#include <QObject>\n\n")

	for _, st := range gp.Structs {
		f.WriteString("class GMLGen" + st.Name + " : public QObject\n")
		f.WriteString("{\n")
		f.WriteString("    Q_OBJECT\n")

		// Add all signals.
		if len(st.Signals) > 0 {
			f.WriteString("signals:\n")
			for _, s := range st.Signals {
				f.WriteString("    void " + s.Name + "(") // TODO: return value.

				// Add the parameters.
				for i, p := range s.Params {
					if i != 0 {
						f.WriteString(", ")
					}
					f.WriteString(p.Type + " " + p.Name) // TODO: to C++ types.
				}
				f.WriteString(");\n")
			}
		}

		f.WriteString("};\n\n")
	}

	f.WriteString("#endif\n")
	return
}
